\documentclass[12pt]{scrartcl}
\input{config.tex}

\begin{document}

\title{CyXtal: C(P)ython Package for Crystal Plasticity Data Analysis}
\subtitle{development note}
\author{Chen Zhang}
\maketitle

\section{Module: ctools}

\section{Module: cxtallite}

\section{External Module: ext\_aps}

\subsection{parsers.py}
This particular module include several function that help facilitate the analysis of data collected at beamline-34-ID-E at Advanced Photon Source in Argonne National Lab.
%
\begin{enumerate}

\item \textbf{parser\_xml(\ldots)} \\

\item \textbf{strain\_refine(\ldots)} \\
The algorithm of strain refinement is based on the software package ``LaueGo'' developed and maintained by Dr. Tischler at APS, ANL.
\footnote{\url{http://www.aps.anl.gov/Sectors/33_34/microdiff/}}

%need a good summary of the algorithm used in finding the crystal orientation as well as how the strain refinement is done.
The strain refinement is not a direct (deterministic) measurement of strain using DAXM characterization.
Instead, the strain tensor extracted from the Laue diffraction pattern is more of a ``guessed value''. 
The general algorithm of extracting strain tensor from DAXM scan data is as follows:
%
\begin{itemize}
\item 
Acquire the crystal orientation by forward prediction of the Laue diffraction pattern.
Due to small strain and experimental measurement error, the simulated Laue pattern will only partially match the measured pattern. 
Here the word ``partially'' has two levels of meanings:
	\begin{itemize}
	\item
	Only some of the diffraction spots are used to identify the crystal orientation of the voxel as it is not possible to match all diffraction spots in the pattern due to non-ideal deconvolution process.
\footnote{The shadows from neighboring grains and echoes from sample internal cannot be fully eliminated during the deconvolution of the diffraction pattern, which is used to acquire Laue pattern for each voxel during post processing of DAXM data.}
	\item
	The matching between the calculated diffraction spots and measured diffraction spots are not perfect. 
	The difference between calculation and measurements can be attributed to experimental error (uncontrollable and hopefully small) and the residual strain present in the crystal lattice, which distort the diffraction spots from its ideal position. 
	\end{itemize}
	
	\item
	Using the crystal orientation obtained by ignoring the lattice distortion (allowing relatively big mismatch of Laue patterns), it is possible to calculate the ideal [reciprocal] lattice vectors for given voxel.
	Perturbing the ideal [reciprocal] lattice vectors (or lattice constants) and recalculating the diffraction spots, one can theoretically stumble upon the real lattice vectors with lattice strain present. 
	Comparing the transformation matrix between the ideal and real, the deformation gradient can be found through
\[
	\tnsr F = \tnsr V_\text{ideal} \tnsr V_\text{real}^T
\]
where \tnsr V is the bases formed by [reciprocal] lattice vectors.
	
	With the deformation gradient known, it is fairly easy to calculate the strain tensor through the Green strain tensor,
\begin{align*}
	\tnsr C &= \tnsr F^T \tnsr F \\
	           &= (1 + \tnsr \epsilon)^2 \\
	           &\approx 1 + 2 \tnsr \epsilon + O(\tnsr \epsilon^2)
\end{align*}
	So the strain tensor for given voxel can be approximated by
\[
	\tnsr \epsilon = \dfrac{1}{2}(\tnsr F^T \tnsr F - \tnsr I)
\]

	\item
	Since it is not possible to directly compute $\tnsr V_\text{real}$, an automated optimization process is used to find a well ``guessed'' $\tnsr V_\text{real}$.
	However, it is possible that different optimization algorithm and initial guessing conditions will lead to different $\tnsr V_\text{real}$, which is why the strain tensor extracted using this method is not deterministic.

	\end{itemize} 
\end{enumerate}

Another point worth mentioning here is that the full strain tensor can only be ``guessed'' when the beam energy is known.
In other words, without the knowledge of the length of \tnsr q (diffraction vector), it is not possible to inferred the whole strain tensor.
However, if the volume of the unit cell is assumed to remain constant through deformation, the deviatoric component of the strain tensor is not tied to $||\tnsr q||$.
\footnote{Diffraction vector: $\tnsr q_{hkl} = \tnsr V \cdot (khl) $}
Thus, it is necessary to add this assumption to the optimization if white beam calibration is not done, which add one more step to get the deviatoric strain component,
\[
	\tnsr \epsilon_{dev} = \tnsr \epsilon - \dfrac{1}{3}\text{tr}(\tnsr \epsilon)
\]
\section{External Module: ext\_damask}

\section{External Module: ext\_vtk}

\section{Appendix}
\subsection{Find Base Vectors from Lattice Constants}
\label{sec:lc2bv}
In the strain refinement, one important step is to find the reciprocal lattice vectors from given lattice constants. 
The easiest way to find the reciprocal lattice vectors is to find its dual, real space lattice vectors. 

\begin{figure}[htp]
\centering
\includegraphics[width=.7\linewidth]{UnitCell.png}
\caption{A general unit cell with its six lattice constants}
\label{fig:unitcell}
\end{figure}

\cref{fig:unitcell} shows an example of unit cell randomly oriented in space. 
Although there are six parameters ($a,b,c, \alpha, \beta, \gamma$) available to describe the shape of the unit cell, the exact numerical representation of the unit cell, namely the base lattice vectors, is not easy to determine. 

To make the math a little bit easier, let assume that \vctr a is align with x-axis, which gives us
\[
	\vctr a = (a_1, a_2, a_3) = (a, 0, 0)
\]
Then let's determine the x-y plane through \vctr a and \vctr b.
In other words, \vctr b can be easily written out as
\[
	\vctr b = (b_1, b_2, b_3) = (b\cos\gamma, b\sin\gamma, 0)
\]
For a general unit cell, the volume of the cell is determined through its six lattice parameters/constants, 
\[
	V = abc\sqrt{1 + 2\cos\alpha\cos\beta\cos\gamma - \cos^2\alpha-\cos^2\beta-\cos^2\gamma}
\]
The volume of the unit cell can also be calculated through 
\[
	V = A_{xy}\cdot c_z = abc_3\sin\gamma 
\]
which gives us 
\[
	c_3 = \dfrac{V}{ab\sin\gamma}
\]
Arbitrary choice of the reference system should not affect the angle between two vectors, which gives us 

\begin{align*}
	\vctr a \cdot \vctr c &= ac\cos\beta   = a_1c_1 + a_2c_2 + a_3c_3 \\
	\vctr b \cdot \vctr c &= bc\cos\alpha = b_1c_1 + b_2c_2 + b_3c_3	
\end{align*}
Since \vctr a and \vctr b are known, we have
\begin{align*}
	a_1c_1 + 0 + 0 &= ac_1 = ac\cos\beta \\
	b_1c_1 + b_2c_2 + 0 &= bc_1\cos\gamma  + bc_2\sin\gamma  = bc\cos\alpha
\end{align*}
Solve the above linear system, we have
\begin{align*}
	c_1 &= c\cos\beta \\
	c_2 &= \dfrac{\cos\alpha - \cos\beta\cos\gamma}{\sin\gamma}c
\end{align*}
So the last base vector, \vctr c can be expressed as 
\[
	\vctr c = ( c \: \cos\beta, 
	                c \: \dfrac{\cos\alpha - \cos\beta\cos\gamma}{\sin\gamma}, 
	                \dfrac{V}{ab\sin\gamma})
\]
where $V$ is the volume of the unit cell.

To sum it up, for a general unit cell with six lattice parameters known, if we select \vctr a to be x-axis and \vctr b to lie in the x-y plane, the expression of base lattice vectors can be expressed as 
\begin{align*}
	\vctr a &= (a, 0, 0) \\
	\vctr b &= (b\cos\gamma, b\sin\gamma, 0) \\
	\vctr c &= ( c \: \cos\beta, 
	                c \: \dfrac{\cos\alpha - \cos\beta\cos\gamma}{\sin\gamma}, 
	                \dfrac{V}{ab\sin\gamma})
\end{align*}
where $V$ is the volume of the unit cell and can be calculate through
\[
	V = abc\sqrt{1 + 2\cos\alpha\cos\beta\cos\gamma - \cos^2\alpha-\cos^2\beta-\cos^2\gamma}.
\]

Another convection would be forcing \vctr b to be parallel to y-axis, however this convention has been dropped at APS.
Thus, there is no reason to consider other situation anymore.
\end{document}
